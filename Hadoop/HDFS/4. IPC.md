# 4. IPC 远程过程调用

## 4.1. 基础知识准备

### 4.1.1 远程过程调用 RPC RMI

#### 4.1.1.1 远程过程调用 (Remote Process Call, RPC)

> RPC 只是一种机制，任何语言都可以实现（Java、C、Python）

- **客户端存根（Client Stub）** ：将客户端调用参数打包成一个消息，并请求将此消息发送到服务器端的服务器骨架，然后调用 receive 方法阻塞客户端线程，直到收到响应消息。
- **服务器骨架（Server Skeleton）** ：首先调用 receive 阻塞服务器端线程，等待消息输入；收到消息后，服务器骨架将参数从消息中提取出来，然后以常规方式调用服务器上相应过程；最后，服务器骨架负责将返回值打包成消息，调用 send 函数发送给客户端存根。
- **接口定义语言（Interface Definition Language, IDL）** ：描述了调用接口的相关信息，IDL文件可以包含类型定义、常量声明、进行参数传递时需要的一些其他信息和注释。
#### 4.1.1.2 远程方法调用 (Remote Method Invokation, RMI)

> RMI 是JAVA语言的RPC实现版本

- **远程对象（Remote Object）** ：除了对象本身所在的虚拟机，其他虚拟机也可以调用此对象的方法，并且这些虚拟机一般运行在不同的计算机上。 每个远程对象都实现了一个或者多个功能接口, 功能接口声明了可以由外部系统调用的方法。
- **功能接口** ：需要满足以下条件：

1. 功能接口必须声明为 `public`
2. 功能接口必须继承自 `java.rmi.Remote`
3. 功能接口中的每个方法，除自定义异常外，必须将 `java.rmi.RemoteException` 声明于其 throws 中
4. 在远程方法声明中，作为参数或者返回值的远程对象，或者包含在其他非远程对象中的远程对象，必须声明为其对应的功能接口，而不是实际的实现类

- **远程对象实现** ：远程对象必须继承自 java.rmi.server.UnicastRemoteObject 类，并实现功能接口。 
- **远程对象注册**：需要先执行 **bin/rmiregister** 命令，然后在Java程序中，注册远程对象。

```java
public class RMIDemo {
	public static class RMIFileStatus implements Serializable{
		private static final long serialVersionUID = 1L;
		private String fileName;
		public String getFileName() {
			return fileName;
		}
		public void setFileName(String fileName) {
			this.fileName = fileName;
		}
		public RMIFileStatus(String fileName) {
			this.fileName = fileName;
		}
	}
	// 功能接口
	public static interface RMIQueryStatus extends Remote{
		RMIFileStatus getFileStatus(String fileName) throws RemoteException;
	}
	// 远程对象
	public static class RMIQueryStatusImpl extends UnicastRemoteObject 
		implements RMIQueryStatus{
		private static final long serialVersionUID = 1L;
		public RMIQueryStatusImpl() throws RemoteException {
			super();
		}
		@Override
		public RMIFileStatus getFileStatus(String fileName)
				throws RemoteException {
			RMIFileStatus status = new RMIFileStatus(fileName);
			return status;
		}
	}
	public static final String RMI_URL = "rmi://localhost:12090/query";
	public static class Server {
		// 在服务器端绑定 远程对象到本地，在此之前需要先运行 bin/rmiregister 命令启动 Java RMI 注册服务
		public static void main(String[] args) {
			try {
				RMIQueryStatusImpl queryService = new RMIQueryStatusImpl();
				LocateRegistry.createRegistry(12090);
				Naming.rebind(RMI_URL, queryService);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	public static class Client {
		//在客户端获得远程对象的引用
		public static void main(String[] args) {
			try {
				RMIQueryStatus query = (RMIQueryStatus) Naming.lookup(RMI_URL);
				RMIFileStatus status = query.getFileStatus("/tmp/testRM");
				System.out.println(status);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}	
}
```

- **服务器骨架**：通过继承 **UnicastRemoteObject** 类，远程对象类中包含了 RMI骨架功能。
- **客户端存根**：客户端存根依赖代理机制 **java.lang.reflect.Proxy** 动态生成的。


#### 4.1.1.3 WEB 服务（Web Service）

- webservice是在http协议上传递xml文本文件，与语言和平台无关

> [远程通信的几种选择（RPC，Webservice，RMI，JMS的区别）](https://blog.csdn.net/shan9liang/article/details/8995023)


### 4.1.2 Java 动态代理

>  动态代理主要包含两个功能：

1. 动态创建接口的实现类
2. 调用转发

> 其中第一个功能由 **Proxy** 类完成，有四个重要的函数

- **Proxy.getProxyClass()**：用于获得代理类的 Class 对象， 该代理类将实现参数 interfaces 指定的所有接口，这个 Class 对象只会创建一次。通过这个方法获得的代理类都会包含一个以 **InvocationHandler** 作为参数的构造对象。

```java
public static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) {
   // ......
}
```

- **Proxy.newProxyInstance()**  通过反射机制创建代理对象实例：

```java
public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) {
    //......
    final Class<?>[] intfs = interfaces.clone();
    //.....
    //获得代理类的 Class 对象
    Class<?> cl = getProxyClass0(loader, intfs);
    //.....
    // 获得构造参数
    final Constructor<?> cons = cl.getConstructor({InvocationHandler.class});
    //.......
    // 创建并返回代理对象
    return cons.newInstance(new Object[]{h});
}
```
- **Proxy.isProxyClass()** : 判断 java.lang.Class 对象是否是代理类。
- **Proxy.getInvocationHandler()** :  获取代理实例对应的调用处理程序。


> 动态代理的第二个功能，调用转发，则由 **InvocationHandler** 接口的实例完成，此接口只包含一个函数：

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

> 当用户调用 由Proxy创建的对象的方法时，将会全部转发给 InvocationHandler 的 invoke 方法。

```java
public class ProxyDemo {
	public static class DPFileStatus implements Serializable{
		private static final long serialVersionUID = 1L;
		private String filename;
		public String getFilename() {
			return filename;
		}
		public void setFilename(String filename) {
			this.filename = filename;
		}
		public DPFileStatus(String filename) {
			this.filename = filename;
		}
		@Override
		public String toString() {
			return "DPFileStatus [filename=" + filename + "]";
		}
	}
	// 功能接口（可以是多个）
	public static interface DPQueryStatus {
		DPFileStatus getFileStatus(String filename);
	}
	// 目标类
	public static class DPQueryStatusImpl implements DPQueryStatus{
		@Override
		public DPFileStatus getFileStatus(String filename) {
			return new DPFileStatus(filename);
		}	
	}
	public static class DPInvocationHandler implements InvocationHandler{
		// 目标对象
		public DPQueryStatusImpl dpqs ;
		public DPInvocationHandler(DPQueryStatusImpl dpqs){
			this.dpqs = dpqs;
		}
		/*
		 * 如果结合RMI机制的话，此处的目标对象应该是服务器端的远程对象，在 invoke 方法中需要完成几个步骤：
		 * 1、将方法的参数 args 、目标对象的信息 proxy、以及目标函数的信息进行序列化并且打包
		 * 2、将数据发送到代理对象的服务器上，并且阻塞当前线程，等待服务器的返回结果
		 * 3、将返回数据进行解析（解析数据包、反序列化），并得到最终的函数返回值，return出去
		 */
		@Override
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			// 对参数进行处理
			String filename = "home/" + (String)args[0];
			// 转发给真实对象
			Object result = method.invoke(dpqs, new Object[]{filename});
			// ....
			//对返回值进行处理		
			return result;
		}
	}
	public static class DPProxy {
		// 构造代理对象
		public static DPQueryStatus create(DPQueryStatusImpl dpqs){
			Class<?>[] interfaces = new Class<?>[]{DPQueryStatus.class};
			DPInvocationHandler handler = new DPInvocationHandler(dpqs);
			Object result = Proxy.newProxyInstance(dpqs.getClass().getClassLoader(), 
					interfaces, handler);		
			return (DPQueryStatus) result;
		}
	}
	public static void main(String[] args) {
		DPQueryStatus query = DPProxy.create(new DPQueryStatusImpl());
		DPFileStatus status = query.getFileStatus("tmp/testDP");
		System.out.println(status);
	}	
}
```

---

> **Proxy 在 RMI 中的使用总结**：

- 远程方法调用（RMI）包括几个重要对象：功能接口、远程对象、客户端存根、服务器端骨架。
    - 其中功能接口可以是多个，定义了客户端可以调用的方法；
    - 远程对象实现了所有功能接口，是真正干活的对象，并需要注册在服务器端；
    - 客户端存根负责将客户端的函数调用信息封装并发送到服务器端，并阻塞线程等待返回结果；
    - 服务器骨架负责将客户端的调用数据解析并调用远程对象的函数，将结果封装返回到客户端。
- RMI 中的客户端存根的实现需要使用 Proxy 机制
    - 通过 Proxy.newProxyInstance() 函数可以获得远程对象的代理对象;
    - InvocationHandler.invoke() 函数中完成客户端调用信息的封装、发送到服务器端、阻塞线程等待调用结果、解析返回数据、返回函数调用的返回值。


### 4.1.3 Java NIO

- Java NIO 包括 `Buffer`、`Channel`、`Selector` 三大类抽象。

#### 4.1.3.1 缓冲区 Buffer

- 传统的IO是基于流的，是基于字节的，即一个字节按着一个字节、按顺序提供数据，虽然基于性能考虑，流也可以传输字节数据，但是基本的流概念要求一次传送一个字节；
- NIO是基于块的，即Buffer，在读写通道数据时，这些数据必须先存储在缓冲区Buffer中，一次读写一个缓冲区的数据。


> Buffer 代表了一个 **有限容量的容器**， 其本质是一个数组，在读写数据时，Buffer具有一些内部状态，用来跟踪缓冲区的当前位置：

- **capacity** ：缓冲区的容量，通过 `Buffer.capacity()` 可以获得，capacity 不能修改；
- **position** ：是下一个要读取或者写入的元素的索引，可以由 `position()` 和 `position(int)` 获取和设置；
- **limit** ：是第一个不应该读取或者写入的元素索引，可以由 `limit()` 和 `limit(int)` 获取和设置；
- **mark** : 通过 `mark()` 方法设置一个标记，然后利用 `reset()` 方法，可以将 `position` 重置为 `mark()` 方法设置的位置。

> 0 <= mark <= position <= limit <= capacity

- **ByteBuffer** : Hadoop IPC 中使用的 Buffer 子类，通过工厂方法的 **创建对象**

```java
public abstract class ByteBuffer extends Buffer implements Comparable<ByteBuffer> {
     public static ByteBuffer allocate(int capacity) {
        // ...
     }
     public static ByteBuffer wrap(byte[] array, int offset, int length) {
        // ...
     }
     public static ByteBuffer wrap(byte[] array) {
         //...
     }
}
```

- **读取/写入方法**： 通过 get 和 put 两种类型的方法进行读取和写入操作：
    - 基于**相对位置**：基于目前缓冲区的位置 `position` 的当前值，在读取和写入过程，会改变 `position` 的值；
    - 基于**绝对位置**：必须提供读取/写入的位置，该操作不会改变 `position` 值

```java
// 基于相对位置
public byte get()
public ByteBuffer get(byte[] dst)
public ByteBuffer get(byte[] dst, int offset, int length)
public ByteBuffer put(byte b)
public final ByteBuffer put(byte[] src)
public ByteBuffer put(byte[] src, int offset, int length)
public ByteBuffer put(ByteBuffer src)
// 基于绝对位置
public byte get(int index)
public ByteBuffer put(int index, byte b)
```

- **其他重要方法** ：
    - **clear()** : 清空缓冲区，`position=0`, `limit=capacity`, `mark=-1`。
    - **flip()** : 将缓冲区准备为数据传出状态，在**读取缓冲区之前**，调用这个方法，`limit=position`, `position=0`, `mark=-1`。
    - **rewind()**：如果要**多次读取缓冲区**里的数据，可以在两次读取间调用这个方法，`positon=0`, `mark=-1`。
    - **compact()**：将 `position` 和 `limit` 间的数据复制到缓冲区的开始位置，为后续的 `put() / read()` 调用让出空间。调用结束后，`position` 的值被设置为数据的长度，也就是原来的 limit-position的值， limit 被设置为 capacity。**缓冲区中还有未读出的数据，此时又要写入数据**，则调用此方法。
    - **remaining()**：获得缓冲区中剩余可以写入/读取的空间大小， limit - position。


#### 4.1.3.2 通道 Channel

> Channel 实例代表了一个和设备的连接， **ServerSocketChannel / SocketChannel**, **FileChannel** 等。

- **ServerSocketChannel / SocketChannel** 与传统的 **ServerSocket / Socket** 区别在于：
    - **ServerSocketChannel / SocketChannel** 可以工作在 **非阻塞状态**；
    - **SocketChannel** 的读写数据时采用 ByteBuffer 作为参数；
    - **ServerSocketChannel / SocketChannel** 的使用需要和选择器 Selector 配合工作。

#### 4.1.3.3 选择器 Selector

> 选择器 Selector 的使用方法：

1. 通过 Selector 的静态工厂方法创建 Selector 实例：

```java
Selector selector = Selector.open();
```

2. 通过 Channel 的注册方法，将 Selector 注册到想要监控的 Channel 实例上，同时指定对此 Channel 实例感兴趣的事件：

```java
SelectionKey readKey = channel.register(selector, SelectionKey.ON_READ);
```

> Selector 和 Channel 是多对多的关联，并且关联信息保存在 SelectionKey 中.

- **SelectionKey** 维护了一个通道上感兴趣的四种事件类型：
    - **OP_ACCEPT**：通道上有连接请求
    - **OP_CONNECT**：通道连接已经建立
    - **OP_WRITE**：通道已经可写
    - **OP_READ**：通道已经可读

- **SelectionKey.selector()** 方法可以获得关联的 Selector对象，**SelectionKey.channel()** 方法可以获得关联的 Channel对象，**SelectionKey.cancel()** 方法可以取消关联。

- **SelectionKey** 的 **attachment** 成员变量可以保存处理通道上请求的一些上下文信息。

3. 调用 Selector 对象的 select() 方法阻塞线程，对绑定的所有Channel 进行监听，直到一个或者多个通道准备好I/O操作，或者超时:

```java
selector.select();
```

> 如果 select() 返回值大于0，则表明有需要处理的 I/O 事件发生， selector 会将对应的 Channel 放入 Selected-key set 中，通过 Selector.selectedKeys() 可以获得该集合，并迭代处理 I/O 操作。


#### 4.1.3.4 NIO 实例

```java
public class NIODemo {
	public static final int PORT = 9999;
	public static final long TIMEOUT = 1000;
	public static class NIOServer {
		public static void main(String[] args) 
				throws IOException {
			// 打开一个 Selector
			Selector selector = Selector.open();
			// 打开一个 ServerSocketChannel
			ServerSocketChannel listenChannel = ServerSocketChannel.open();
			// 配置为异步模式
			listenChannel.configureBlocking(true);
			// 绑定到指定端口
			listenChannel.socket().bind(new InetSocketAddress(PORT));
			//注册
			listenChannel.register(selector, SelectionKey.OP_ACCEPT);
			// 进入服务器循环，等待 I/O事件
			while(true) {
				// 返回值为0，则没有事件
				if(selector.select(TIMEOUT) == 0) {
					System.out.println(".");
					continue;
				}
				// 获取已选键集
				Iterator<SelectionKey> iter = selector.selectedKeys().iterator();
				while(iter.hasNext()){
					// 对于已选键集中的每个键
					SelectionKey key = iter.next();
					// 将已选键从键集中删除
					iter.remove(); 	
					if(key.isAcceptable()) {
						SocketChannel channel = listenChannel.accept();
						channel.configureBlocking(true);
						SelectionKey connKey = channel.register(selector, SelectionKey.OP_READ);
						NIOServerConnection conn = new NIOServerConnection(connKey);
						connKey.attach(conn);
					} else if (key.isReadable()){
						NIOServerConnection conn = (NIOServerConnection) key.attachment();
						conn.handleRead();
					} else if(key.isWritable() && key.isValid()){
						NIOServerConnection conn = (NIOServerConnection) key.attachment();
						conn.handleWrite();
					}
				}
			}
		}
	}
	public static class NIOServerConnection {	
		private SelectionKey selectionKey;
		private ByteBuffer buffer = ByteBuffer.allocate(1024);
		public NIOServerConnection(SelectionKey selectionKey){
			this.selectionKey = selectionKey;
		}
		public void handleRead() throws IOException{
			SocketChannel channel = (SocketChannel) selectionKey.channel();
			long len = channel.read(buffer);
			if(len == -1) {
				channel.close();
			} else {
				selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
			}
		}
		public void handleWrite() throws IOException{
			buffer.flip(); // 缓冲区转换到读状态
			SocketChannel channel = (SocketChannel) selectionKey.channel();
			channel.write(buffer);
			if(!buffer.hasRemaining()){
			// 缓冲区中没有数据了，则将感兴趣事件设置为读
				selectionKey.interestOps(SelectionKey.OP_READ);
			}
			buffer.compact(); // 缓冲区转换到写状态
		}
	}
}
```

---

## 4.2. Hadoop 中的远程调用 IPC 概述

> IPC (Inter-Process Communication)


> Hadoop IPC 的实现主要有两类流程，分别是 **IPC 连接相关过程** 和 **IPC 方法调用相关过程**。 

> 核心源码主要主要在 **RPC.java** 、**Client.java**、 **Server.java** 三个文件中。

### 4.2.1 Hadoop IPC 连接相关过程

> IPC Connection 是客户端与服务器端关系的一个抽象，建立在TCP连接之上，它的实现包括 **连接建立**、**连接上的数据读写**、**连接维护**、**连接关闭** 四个流程。

#### 4.2.1.1 IPC 连接成员变量


- **Client.Connection** ，分为三类成员变量： 与 TCP 相关、与 IPC 连接相关、与远程调用相关: 

```java
private InetSocketAddress server; // IPC 服务器的 ip 和 port
private final ConnectionId remoteId; // IPC 连接 ID
private Socket socket = null;  // IPC 连接的 socket
private DataInputStream in;     // socket 对象上对应的输入流对象
private DataOutputStream out;  // socket 对象上对应的输出流对象
// 当前正在处理的 Call
private Hashtable<Integer, Call> calls = new Hashtable<Integer, Call>();
// 最后一次通信时间
private AtomicLong lastActivity = new AtomicLong();
// 连接关闭标记
private AtomicBoolean shouldCloseConnection = new AtomicBoolean(); 
// 导致IPC连接关闭的异常
private IOException closeException; 
```

> **remoteId** : 用于 IPC 连接复用

> **lastActivity** : 用于记录最后一次 I/O 的时间，如果 IPC 连接长时间没有数据交换，即没有 I/O 发生，那么 IPC 连接会进行相应的维护工作。

> **shouldCloseConnection** : 根据这个标记，可以停止 Connection 线程的工作。

> **closeException** : 当 IPC 连接的关闭是由异常导致的，则会记录在这个变量中。

> **calls**： 保存目前 IPC Connection 上的所有 Call。

- **Server.Connection**, 分为三类成员变量： 与 TCP 相关、与 IPC 连接相关、与远程调用相关: 

```java
// 是否已经读入 RPC Connection Header
private boolean connectionHeaderRead = false; 
// 是否已经读入 connection header 之后的信息
private boolean connectionContextRead = false; 
private SocketChannel channel;
private ByteBuffer data;
private ByteBuffer dataLengthBuffer;
private LinkedList<Call> responseQueue;
private volatile int rpcCount = 0; // 当前正在处理的 rpc 请求数
private long lastContact;
private int dataLength;
private Socket socket;
// 客户端的主机名和端口
private String hostAddress;
private int remotePort;
private InetAddress addr;
IpcConnectionContextProto connectionContext;
String protocolName;
UserGroupInformation user = null;
```

> 与 TCP 相关的主要是 SocketChannel 和配合 SocketChannel 工作的一些缓冲区

#### 4.2.1.2 建立 IPC 连接

> IPC 连接是在 IPC 调用的时候才建立的：

```java
private Hashtable<ConnectionId, Connection> connections = new Hashtable<ConnectionId, Connection>(); // 复用 Connection 对象    
private Connection getConnection(ConnectionId remoteId, Call call, int serviceClass) throws IOException {
    // ......
    do {
      synchronized (connections) {
        connection = connections.get(remoteId);
        if (connection == null) {
          connection = new Connection(remoteId, serviceClass);
          connections.put(remoteId, connection);
        }
      }
    } while (!connection.addCall(call));  // 防止讲一个 call 放入一个将要被关闭的 connection 中
    //......
    connection.setupIOstreams();
    return connection;
}
```

#### 4.2.1.3 数据分帧和读写

#### 4.2.1.4 维护IPC连接

#### 4.2.1.5 关闭IPC连接

### 4.2.2 Hadoop IPC 方法调用相关过程

## 4.3 Hadoop IPC 源码分析

### 4.3.1 Client

> 负责IPC客户端的通信

```java
// org.apache.hadoop.ipc.Client
public class Client {
    //......
}
```

> 重要的内部类主要有三个： `ConnectionId`， `Connection`，`Call`

#### 4.3.1.1 ConnectionId

>  这个类保存了服务器端地址(address)和用户凭证(ticket)，服务器和客户端的 `Connection` 可以由 `<remoteAddress, protocol, ticket>` 唯一标识。 

> `ConnectionId` 对象持有了其对应 `Connection` 对象的一些关键信息。


```java
// org.apache.hadoop.ipc.Client.ConnectionId
public static class ConnectionId {
   // ......
}
```

> 部分成员变量解析

```java
    InetSocketAddress address; // 服务器端地址  IP + Port
    UserGroupInformation ticket; // 用户信息
    final Class<?> protocol;   
    private final int rpcTimeout;   // RPC 连接超时
    private final int maxIdleTime; // 如果连接的闲置时间超过 maxIdleTime，则此连接会被剔除
    private final RetryPolicy connectionRetryPolicy;  // 重连策略
    private final int maxRetriesOnSocketTimeouts; // 最大尝试重连次数
    private final boolean doPing; // 是否需要发送 ping 消息
    private final int pingInterval; // 发送 ping 消息的时间间隔
    private final Configuration conf;   // 用来获取一些系统配置参数
```

#### 4.3.1.2 Connection

> Connection 是 Thread 子类，负责读取响应并通知 Call 对象。每一个 Connection 对象持有一个连接到远程地址的socket的对象，多个 Call 对象会复用这一个socket对象：响应可能是无序交付的。 


```java
// org.apache.hadoop.ipc.Client.Connection
private class Connection extends Thread {
    //......
}
```

> 部分成员变量解析

```java
    private InetSocketAddress server;   // 服务器端的 ip:port
    private final ConnectionId remoteId;    // ConnectionId 对象，相当于是当前 Connection 对象的唯一标识符，或者可以看做是 key
    private AuthMethod authMethod;  // 认证方法
    private int serviceClass;
	//// 连接相关
    private Socket socket = null;   // 持有的 Socket 对象， 此对象连接到 server 变量所标识的服务器 
    private DataInputStream in;     // Socket 对象上的输入流
    private DataOutputStream out;   // Socket 对象上的输出流
    private int rpcTimeout;         // RPC 连接超时
    private int maxIdleTime;        // 闲置时间超过这个变量，则会将此 Connection 对象删除
    //// 重连相关
    private final RetryPolicy connectionRetryPolicy;  // 重连策略 
    private int maxRetriesOnSocketTimeouts; 		 // 最大尝试重连次数
    private final boolean doPing; 					// 是否需要发送 ping 消息
    private final int pingInterval;                   // 发送 ping 消息的时间间隔
    private ByteArrayOutputStream pingRequest;        // ping 请求，发送 ping 消息
    //// 调用相关
    private Hashtable<Integer, Call> calls = new Hashtable<Integer, Call>();    // 当前 Connection 对象中所有活跃的 Call 对象，即已经发送到服务器但还没得到返回值的调用
    private AtomicLong lastActivity = new AtomicLong(); // 最后一次 I/O 操作的时间
    private AtomicBoolean shouldCloseConnection = new AtomicBoolean();  // 标识当前 Connection 对象是否关闭
    private IOException closeException;       // 如果不是正常关闭，则造成关闭的异常
    private final Object sendRpcRequestLock = new Object(); // 发送 RPC 请求时需要 同步，此对象是同步锁
```

##### 4.3.1.2.1  建立连接相关成员函数

> 主要有四个相关函数：

- **setupConnection()** :   负责建立 Socket 连接
- **writeConnectionHeader()** ： 负责建立连接之后发送 连接头 信息到服务器端
- **writeConnectionContext()** ： 负责建立连接之后发送 连接上下文 信息到服务器端 
- **setupIOstreams()** : 当Client创建Connection对象时，只需要调用这个方法，则会完成整个创建过程
    - 调用 **setupConnection()** 建立 Socket 连接
    - 基于 Socket 连接，创建 I/O 对象
    - 调用 **writeConnectionHeader()** 和 **writeConnectionContext()** 将必要信息通过输出流对象发送到服务器端
    - 调用 **start()** 函数启动线程，监听服务器端的响应

```java
    // 建立 Socket 连接
    private synchronized void setupConnection() throws IOException {
      // .......
      while (true) {
        try {
          // 创建 Socket 对象
          this.socket = socketFactory.createSocket();
          this.socket.setTcpNoDelay(tcpNoDelay);
          this.socket.setKeepAlive(true); 
          // 绑定 Socket 对象到本地
          // .....
          String host = SecurityUtil.getHostFromPrincipal(remoteId.getTicket().getUserName());
          InetAddress localAddr = NetUtils.getLocalInetAddress(host);
          if (localAddr != null) {
                this.socket.bind(new InetSocketAddress(localAddr, 0));
          }
          // 建立 Socket 连接到服务器
          NetUtils.connect(this.socket, server, connectionTimeout);
          if (rpcTimeout > 0) {
            pingInterval = rpcTimeout;
          }
          this.socket.setSoTimeout(pingInterval);
          // 完成 Connection 建立工作，结束函数
          return;
        } catch (ConnectTimeoutException toe) {
          //.......
        }
      }
    }
    /**
     * 当连接建立时，发送连接头信息到服务器端
     * +----------------------------------+
     * |  "hrpc" 4 bytes                  |      
     * +----------------------------------+
     * |  Version (1 byte)                |
     * +----------------------------------+
     * |  Service Class (1 byte)          |
     * +----------------------------------+
     * |  AuthProtocol (1 byte)           |      
     * +----------------------------------+
     */
    private void writeConnectionHeader(OutputStream outStream)
        throws IOException {
      DataOutputStream out = new DataOutputStream(new BufferedOutputStream(outStream));
      out.write(RpcConstants.HEADER.array());
      out.write(RpcConstants.CURRENT_VERSION);
      out.write(serviceClass);
      out.write(authProtocol.callId);
      out.flush();
    }
    /*
     * 将 connectionContextHeader 发送连接上下文信息到服务器端
     */
    private void writeConnectionContext(ConnectionId remoteId, AuthMethod authMethod) throws IOException {
      // 构建 message 和 connectionContextHeader
      IpcConnectionContextProto message = ProtoUtil.makeIpcConnectionContext(
          RPC.getProtocolName(remoteId.getProtocol()),
          remoteId.getTicket(),
          authMethod);
      RpcRequestHeaderProto connectionContextHeader = ProtoUtil
          .makeRpcRequestHeader(RpcKind.RPC_PROTOCOL_BUFFER,
              OperationProto.RPC_FINAL_PACKET, CONNECTION_CONTEXT_CALL_ID,
              RpcConstants.INVALID_RETRY_COUNT, clientId);
      RpcRequestMessageWrapper request =
          new RpcRequestMessageWrapper(connectionContextHeader, message);
      // 发送消息
      out.writeInt(request.getLength());
      request.write(out);
    }
    // 连接到服务器并开启 I/O 流， 然后发送 header 信息到服务器并启动连接线程等到响应
    private synchronized void setupIOstreams() {
      //.....
      try {
        // ......
        while (true) {
          // 构建 Socket 连接
          setupConnection();
          // 从 Socket 连接中创建输入/输出流对象
          InputStream inStream = NetUtils.getInputStream(socket);
          OutputStream outStream = NetUtils.getOutputStream(socket);
          // 将 header 信息写入到输出流
          writeConnectionHeader(outStream);
          // ......
          if (doPing) {
            inStream = new PingInputStream(inStream);
          }
          this.in = new DataInputStream(new BufferedInputStream(inStream));
          this.out = new DataOutputStream(outStream);
          // 将 上下文信息写入到输出流
          writeConnectionContext(remoteId, authMethod);
          // 更新最后一次 I/O 时间
          touch();
          // 启动 Connection 线程，等待服务器端响应
          start();
          return;
        }
      } catch (Throwable t) {
        // ....
      }
    }
```

##### 4.3.1.2.2  关闭连接相关成员函数

> 主要有三个方法：

- **cleanupCalls()** : 负责删除 connection 对象中 calls 队列中的所有 call
- **closeConnection()** : 负责关闭 socket 连接
- **close()** : 关闭 connection 对象时只需要调用这个方法，则会完成所有的关闭过程
    -  先将当前 connection 对象 从 Client 对象的 connections 队列中删除
    -  关闭 socket 连接的 I/O 对象
    -  调用 **cleanupCalls()** 删除所有 call 对象
    -  调用 **closeConnection()**, 关闭 socket 连接


```java
    // 删除所有 call 对象
    private void cleanupCalls() {
      Iterator<Entry<Integer, Call>> itor = calls.entrySet().iterator() ;
      while (itor.hasNext()) {
        Call c = itor.next().getValue(); 
        itor.remove();
        c.setException(closeException); 
      }
    }
    // 关闭连接
    private void closeConnection() {
      // 关闭 socket 连接
      try {
        socket.close();
      } catch (IOException e) {
        LOG.warn("Not able to close a socket", e);
      }
      // 将 socket 设置为 null， 以便下次调用 setupIOstreams() 可以重新启动连接
      socket = null;
    }    
    /** 关闭 connection，及其相关资源 */
    private synchronized void close() {
      // .......
      // 第一步：先将当前 connection对象 从 Client 对象的 connections 队列中删除
      synchronized (connections) {
        if (connections.get(remoteId) == this) {
          connections.remove(remoteId);
        }
      }
      // 第二步：关闭 socket 连接的 I/O 对象
      IOUtils.closeStream(out);
      IOUtils.closeStream(in);
      disposeSasl();
      // 第三步：删除所有 call 对象
      if (closeException == null) {
        if (!calls.isEmpty()) {
          // .......
          cleanupCalls();
        }
      } else {
        // .......
        cleanupCalls();
      }
      // 第四步：关闭 connection，即关闭 socket 连接
      closeConnection();
      // ......
    }
```


##### 4.3.1.2.3  远程调用相关成员函数

> 主要包含四个函数：

- **addCall(call)** :  添加 Call 对象到 connection 对象的 calls 队列中
- **receiveRpcResponse()** : 接收来自服务器的响应
    - 获取并解析响应头信息
    - 通过 callId 找到对应的 Call 对象，即找到本次服务器的返回结果是针对哪个 Call 对象的
    - 反序列化响应结果，并从 calls 队列中删除此 call 对象
- **run()** : 监听服务器端的响应，并循环调用 **receiveRpcResponse()** 处理响应。当 Client 对象创建 connection 对象后，会调用 connection.setupIOstreams()，间接调用 start() 方法，从而创建新的线程执行此 run() 方法。 
- **sendRpcRequest(call)** : 向服务器发送 远程调用 call，会先将call对象序列化然后在发送，这个方法可能会被多个线程调用


```java
    // 添加 Call 对象到当前 Connection 对象中
    private synchronized boolean addCall(Call call) {
      if (shouldCloseConnection.get())
        return false;
      calls.put(call.id, call);
      notify();  // 可以让 run() 方法中的  waitForWork() 阻塞立即返回
      return true;
    }
    /** 
     * 接收服务器端的请求，因为这个方法只会被Connection对象的内部方法 run() 调用，所以不需要使用同步块。
     */
    private void receiveRpcResponse() {
      // 更新最后一次 I/O 时间
      touch();
      try {
        // 获取并解析响应头信息
        int totalLen = in.readInt();
        RpcResponseHeaderProto header = 
            RpcResponseHeaderProto.parseDelimitedFrom(in);
        checkResponse(header);
        int headerLen = header.getSerializedSize();
        headerLen += CodedOutputStream.computeRawVarint32Size(headerLen);
        // 通过 callId 找到对应的 Call 对象，即找到本次服务器的返回结果是针对哪个 Call 对象的
        int callId = header.getCallId();
        Call call = calls.get(callId);
        RpcStatusProto status = header.getStatus();
        if (status == RpcStatusProto.SUCCESS) {
          // 远程调用成功，反序列化远程调用的返回值
          Writable value = ReflectionUtils.newInstance(valueClass, conf);
          value.readFields(in);
          calls.remove(callId);     // 从call队列中删除当前call，因为这个call的结果已经返回到了客户端，相当于这个远程调用结束了
          // 调用线程调用 sendRpcRequest(call)，将call发送到服务器端之后，会调用 call.wait()阻塞线程，
          // 此处call.setRpcResponse(value)会间接调用 call.notify(), 使得 call.wait() 立刻返回，相当于通知了调用线程，远程调用已经得到了返回值
          call.setRpcResponse(value); 
          // .......
        } else { 
          // Call 远程调用失败
          // ......
          if (status == RpcStatusProto.ERROR) {
            calls.remove(callId); // 从call队列中删除当前call
            call.setException(re); 
          } else if (status == RpcStatusProto.FATAL) {
            // 关闭Connection
            markClosed(re);
          }
        }
      } catch (IOException e) {
        markClosed(e);
      }
    }
    // Thread 的 run 方法
    public void run() {
      // ...
      try {
        while (waitForWork()) {
        // 等待响应——读或者关闭连接
          receiveRpcResponse();
        }
      } catch (Throwable t) {
        // .......
      }
      close();
      // ......
    }
    /**
     * 这个方法会被其他线程调用，将调用对象 call 发送到服务器
     */
    public void sendRpcRequest(final Call call)
        throws InterruptedException, IOException {
      // ......
      // 序列化 call 对象，这个序列化过程是在调用 sendRpcRequest() 函数的线程中完成的，而不是在 sendParamsExecutor 线程中
      // 序列化call之后的内容包括：
      // 0) Length 下面两个部分的总长度
      // 1) RpcRequestHeader
      // 2) RpcRequest
      // 下面是 ‘1’ 和 ‘2’ 两项的过程
      final DataOutputBuffer d = new DataOutputBuffer();
      RpcRequestHeaderProto header = ProtoUtil.makeRpcRequestHeader(
          call.rpcKind, OperationProto.RPC_FINAL_PACKET, call.id, call.retry,
          clientId);
      header.writeDelimitedTo(d);
      call.rpcRequest.write(d);
      // 同步块，每个 Connection 对象（每个 Socket 连接）同时只能被一个线程使用
      synchronized (sendRpcRequestLock) {
        Future<?> senderFuture = sendParamsExecutor.submit(new Runnable() {
          @Override
          public void run() {
            try {
              synchronized (Connection.this.out) {
                // ......
                byte[] data = d.getData();
                int totalLength = d.getLength();
                out.writeInt(totalLength); // 总长度
                out.write(data, 0, totalLength);// RpcRequestHeader + RpcRequest
                out.flush();
              }
            } catch (IOException e) {
                // ....
            } finally {
                IOUtils.closeStream(d);
            }
          }
        });
        try {
          // 获取 sendParamsExecutor.submit() 的线程的执行结果，也就是此处会产生阻塞，直到发送任务完成，但不会等到服务器的返回结果
          senderFuture.get();
        } catch (ExecutionException e) {
          //......
        }
      }
    }
```


> 一个远程调用过程简述：客户端通过 sendRpcRequest(call) 方法，将客户端调用call发送到服务端，并添加到calls队列中，然后客户端会在 receiveRpcResponse() 方法中等待服务器端的调用结果，从 calls 队列中找到对应的 call 对象，并将返回结果绑定上去。

##### 4.3.1.2.4  其他成员函数

```java
    // 更新最后一次 I/O 操作的时间
    private void touch() {
      lastActivity.set(Time.now());
    }
    // 发送 ping 到服务器端
    private synchronized void sendPing() throws IOException {
      long curTime = Time.now();
      // 到最后一次 I/O 时间的间隔超过设置的 pingInterval，才会发送 ping
      if ( curTime - lastActivity.get() >= pingInterval) {
        lastActivity.set(curTime);
        synchronized (out) {
          out.writeInt(pingRequest.size());
          pingRequest.writeTo(out);
          out.flush();
        }
      }
    }
```


##### 4.3.1.2.5 PingInputStream

> 当读取超时的情况下，这个类会发送一个 ping 到远程服务器，如果没有检测到 错误，则会一直重复直到读取到至少一个字节。

```java
// org.apache.hadoop.ipc.Client.Connection.PingInputStream
private class PingInputStream extends FilterInputStream {
    //......
}
```

> 部分函数分析

```java
      // 处理 timeout 异常， 
      // 如果 connection 即将被关闭或已经处于关闭状态，或者 rpcTimeout > 0，则直接抛出 timeout异常；
      // 否则调用 sendPing()。
      private void handleTimeout(SocketTimeoutException e) throws IOException {
        if (shouldCloseConnection.get() || !running.get() || rpcTimeout > 0) {
          throw e;
        } else {
          sendPing();
        }
      }
      // 从流中读取一个字节，如果读取超时，则调用 handleTimeout()
      // 如果没有检测到异常，则会一直重复直到读入一个字节。
      public int read() throws IOException {
        do {
          try {
            return super.read();
          } catch (SocketTimeoutException e) {
            handleTimeout(e);
          }
        } while (true);
      }
```

#### 4.3.1.3 Call

> 远程调用对象，封装一次调用的信息

```java
// org.apache.hadoop.ipc.Client.Call
static class Call {
    // ......
}
```

> 部分成员变量分析

```java
    final int id;               // 调用 id
    final int retry;            // 重试次数
    final Writable rpcRequest;  // 可序列化的RPC请求对象
    Writable rpcResponse;       // 可序列化的RPC响应对象
    boolean done;               // 如果完成调用过程，则为 true
```

> 成员函数分析

```java
    // 调用完成
    protected synchronized void callComplete() {
      this.done = true;
      notify(); // 调用线程将 call 发送到服务器端，会调用 call.wait() 阻塞线程，此处调用 notify() 可以使得调用线程的 wait() 调用立即返回，并处理返回值
    }
    // Connection.receiveRpcResponse() 函数会调用此方法，并将服务器端的返回结果传入
    public synchronized void setRpcResponse(Writable rpcResponse) {
      this.rpcResponse = rpcResponse;
      callComplete();
    }
```

#### 4.3.1.4 Client 分析

> 部分成员变量

```java
  private static final AtomicInteger callIdCounter = new AtomicInteger(); // 用于生成 callid 的计数器
  private static final ThreadLocal<Integer> callId = new ThreadLocal<Integer>();
  private static final ThreadLocal<Integer> retryCount = new ThreadLocal<Integer>();
  private Hashtable<ConnectionId, Connection> connections = new Hashtable<ConnectionId, Connection>();  // connection 池，保存客户端的所有连接
  private Class<? extends Writable> valueClass;  // class of call values
  private AtomicBoolean running = new AtomicBoolean(true); // 客户端是否运行
  private SocketFactory socketFactory; // 创建 socket 的工厂
  private final int connectionTimeout; // 连接超时
  private final boolean fallbackAllowed;
  private final byte[] clientId;
  final static int CONNECTION_CONTEXT_CALL_ID = -3;
  private final ExecutorService sendParamsExecutor; // 发送 call 到服务器端的执行器
  private final static ClientExecutorServiceFactory clientExcecutorFactory =
      new ClientExecutorServiceFactory();
```


> 部分成员函数

- **createCall()**：创建 call 对象
- **getConnection(remoteId, call, serviceClass)**： 获得connection对象
- **public Writable call(rpcKind, rpcRequest, remoteId, serviceClass)**：
    - 调用  `createCall()` 构建 call 对象
    - 调用  `getConnection()` 获得 connection 对象
    - `connection.sendRpcRequest(call)` 将call对象发送到服务器端
    - `call.wait()` 阻塞线程，等待服务器的返回结果 （`connection.receiveRpcResponse()` 一旦得到返回结果，会调用 `call.notify()`）
    - 返回调用结果

```java
   // 通过给定的 connectionId 从 connection池 中获得一个 connection 对象，
   // 或者创建一个新的 connection 对象并加入到 connection池中。可以复用 connection 对象
  private Connection getConnection(ConnectionId remoteId,
      Call call, int serviceClass) throws IOException {
    // ......
    Connection connection;
    do {
      synchronized (connections) {
        connection = connections.get(remoteId);
        if (connection == null) {
          connection = new Connection(remoteId, serviceClass);
          connections.put(remoteId, connection);
        }
      }
    } while (!connection.addCall(call)); 
    // 建立 connection 连接，这个不放在同步块中，是为了防止服务器响应速度很慢，
    // 导致建立连接的时间过长， 则同步块持续时间过长，其他线程一直不能使用 
    // connections，则会降低整个系统的性能。 
    connection.setupIOstreams();  
    return connection;
  }
  // 创建 call 对象
  Call createCall(RPC.RpcKind rpcKind, Writable rpcRequest) {
    return new Call(rpcKind, rpcRequest);
  }
  // Make a call, passing rpcRequest, to the IPC server defined by remoteId, returning the rpc respond.
  public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,ConnectionId remoteId, int serviceClass) throws IOException {
    // 创建 call 对象
    final Call call = createCall(rpcKind, rpcRequest);
    // 获得 connection 对象
    Connection connection = getConnection(remoteId, call, serviceClass);
    try {
      // 通过 connection 对象，将 call 发送到服务器端
      connection.sendRpcRequest(call);
    } catch (RejectedExecutionException e) {
       //......
    }
    boolean interrupted = false;
    synchronized (call) {
      while (!call.done) {
        try {
        // 等待调用结果，服务器端返回结果后，connection.receiveRpcResponse() 
        // 中会调用 call.setRpcResponse() 并间接调用 call.wait() 使得此处立即返回
          call.wait();  
        } catch (InterruptedException ie) {
          interrupted = true;
        }
      }
     // .....
      if (call.error != null) {
        //..............
      } else {
        return call.getRpcResponse(); // 返回调用结果
      }
    }
  }
```

- Client 总结：
1. 每个 Client 对象有一个 connections 池，持有多个 connection 可以支持复用
2. 客户端当调用 client.call() 对象时，会通过 client.getConnection() 从 connections 池中获取一个 connection 对象，或者创建一个新的 connection 对象，并调用 connection.start() 启动监听线程，监听服务器端的响应
3. 通过 connection.sendRpcRequest(call) 将 call 序列化后发送到服务器端，然后添加到 calls 池中，并调用 call.wait() 阻塞线程，等待服务器端的返回结果
4. connection 监听线程得到服务器端的响应，并将结果反序列化，然后调用 call.notify() 通知调用线程，即 call.wait() 会立即返回
5. 客户端会得到最终的返回结果 

---

### 4.3.2. Server

> 负责IPC服务器端的通信 

```java
// org.apache.hadoop.ipc.Server
public abstract class Server {
    // ......
}
```

#### 4.3.2.1 Call

> 服务器端对调用的封装

```java
// org.apache.hadoop.ipc.Server.Call
  public static class Call implements Schedulable {
      // .......
  }
```

> 部分成员变量

```java
    private final int callId;   // 客户端的 call id
    private final int retryCount; // call 的尝试次数
    private final Writable rpcRequest;   // 客户端传过来的可序列化的RPC请求
    private final Connection connection;  // 与客户端的连接
    private long timestamp;  // call 的接收时间
    private ByteBuffer rpcResponse;       // 这个call的响应
    private final byte[] clientId;      // 客户端id
```

#### 4.3.2.2 Listener

> 监听器，包含多个Reader对象，即包含多个读取线程， Listener 会在一个新的线程中通过 ServerSocketChannel 监听来自客户端的 socket 连接请求，一旦构建连接，则将连接添加到一个 Reader 对象中，在 Reader 对象的线程中负责监听并读取这个连接上的数据请求。


- Listener 中的操作基本是对 Java NIO 的 SocketChannel、 ServerSocketChannel 和 Selector 的使用。

```java
  // org.apache.hadoop.ipc.Server.Listener
  private class Listener extends Thread {
      // .......
  }
```

##### 4.3.2.2.1 Reader

> 读取器，包含一个 connection 队列，每个 connection 中持有一个 socketchannel，Reader 会在一个新的线程中监听 队列中所有的 connection的 socketchannel，如果有请求数据，则读取数据。

```java
// org.apache.hadoop.ipc.Server.Listener.Reader
private class Reader extends Thread {
   // .......
}
```

> 部分成员变量

```java
    final private BlockingQueue<Connection> pendingConnections; // 负责监听的 Connection 队列
    private final Selector readSelector; // 所有 connection 中的 socketchannel 将会绑定到这个 Selector 上
```

> 部分成员函数，主要有有三个函数

- **run()** : 作为Thread的run()，只是简单的调用 doRunLoop() 
- **doRunLoop()**：完成对所有 connection 中的 socketchannel 的监听
- **addConnection()** : 添加一个新的 connection 到 Reader 中


```java
      public void run() {
          // ........
          doRunLoop();
          // ........
      }
      /**
      * 循环监听所有 connection 中的 socketchannel 
      */
      private synchronized void doRunLoop() {
        while (running) {
          SelectionKey key = null;
          try {
           // 将所有 connection 中的 socketchannel 全部绑定到 selector 中
            int size = pendingConnections.size();
            for (int i=size; i>0; i--) {
              Connection conn = pendingConnections.take();
              conn.channel.register(readSelector, SelectionKey.OP_READ, conn);
            }
            // 阻塞线程，直到有可读的 socketchannel
            readSelector.select();
            // 遍历读取每个就绪的 socketchannel 
            Iterator<SelectionKey> iter = readSelector.selectedKeys().iterator();
            while (iter.hasNext()) {
              key = iter.next();
              iter.remove();
              if (key.isValid()) {
                if (key.isReadable()) {
                  doRead(key);  // 完成内容的读取
                }
              }
              key = null;
            }
          } catch (IOException ex) {
            // ......
          }
        }
      }
      /**
      * 添加 connection 到当前 reader 对象
      */
      public void addConnection(Connection conn) throws InterruptedException {
        pendingConnections.put(conn);  // 添加到 connection 队列
        readSelector.wakeup();  // readSelector.select() 会立即返回，通知 doRunLoop() 绑定新的 connection 到readSelector
      }
```

##### 4.3.2.2.2 Listener 分析

> 部分成员变量

```java
    private ServerSocketChannel acceptChannel = null; // 等待客户端的连接请求
    private Selector selector = null; // socket 服务的选择器
    private Reader[] readers = null; // 读取器队列
    private int currentReader = 0;  // 当前读取器的索引
    private InetSocketAddress address; // ServerSocketChannel 监听的地址
```

> 部分成员函数

- **Listener()**: 构造函数，负责创建 `ServerSocketChannel` 和 `Selector` 对象，并将前者注册到后者，同时将 `ServerSocketChannel` 绑定到本地端口，并启动自身线程。
- **run()**：`Thread.run()`， 负责在新的线程中通过 ServerSocketChannel 中监听客户端的 连接请求，并将请求传递给 doAccept() 函数
- **doAccept()**：处理来自客户端的连接请求，并将连接请求封装为 Connection 对象，添加到 Reader 对象中，在Reader对象的独立线程中负责监听并读取此连接上的数据。
- **doRead()**：负责处理 channel 上的 READ 事件，实际的读取过程由 Connection.readAndProcess() 完成

```java
    // 构造函数
    public Listener() throws IOException {
      // .......
      // 创建  ServerSocketChannel 对象
      acceptChannel = ServerSocketChannel.open();
      acceptChannel.configureBlocking(false);
      // 绑定 ServerSocketChannel 到本地端口
      bind(acceptChannel.socket(), address, backlogLength, conf, portRangeConfig);
      // ......
      // 创建一个 selector，并将 ServerSocketChannel 注册到此 Selector 对象上
      selector= Selector.open();
      acceptChannel.register(selector, SelectionKey.OP_ACCEPT);
      // 创建多个 Reader 对象，并启动 Reader 线程
      readers = new Reader[readThreads];
      for (int i = 0; i < readThreads; i++) {
        Reader reader = new Reader(
            "Socket Reader #" + (i + 1) + " for port " + port);
        readers[i] = reader;
        reader.start();
      }
      // .......
    }
    // Thread.run()
    public void run() {
      // ......
      while (running) {
        SelectionKey key = null;
        try {
          getSelector().select();
          Iterator<SelectionKey> iter = getSelector().selectedKeys().iterator();
          while (iter.hasNext()) {
            key = iter.next();
            iter.remove();
            try {
              if (key.isValid()) {
                if (key.isAcceptable())
                  doAccept(key);    // 处理连接请求
              }
            } catch (IOException e) {
            }
            key = null;
          }
        } catch (Exception e) {
          // ......
        }
      }
      // .........
    }
    // 处理连接事件
    void doAccept(SelectionKey key) throws InterruptedException, IOException,  OutOfMemoryError {
      ServerSocketChannel server = (ServerSocketChannel) key.channel();
      SocketChannel channel;
      while ((channel = server.accept()) != null) {
        // 获得 SocketChannel，即与客户端的连接，并完成初始化设置
        channel.configureBlocking(false);
        channel.socket().setTcpNoDelay(tcpNoDelay);
        channel.socket().setKeepAlive(true);
        Reader reader = getReader();    // 从 Reader 数组中取出一个reader对象
        Connection c = connectionManager.register(channel); // 创建一个 connection 对象
        key.attach(c);
        reader.addConnection(c); // 将连接添加到 reader 对象
    }
    // 处理读取事件，Reader 对象中会调用这个方法
    void doRead(SelectionKey key) throws InterruptedException {
      int count = 0;
      Connection c = (Connection)key.attachment();
      if (c == null) {
        return;  
      }
      c.setLastContact(Time.now()); 
      try {
        count = c.readAndProcess();  // 由 Connection.readAndProcess() 完成真正的读取过程 
      } catch (Exception e) {
        // .....
      }
      // .......
    }   
```

#### 4.3.2.3 Connection

> 封装服务器端与客户端的 Socket 连接，其中包含 SockectChannel， 以及此 socket 连接上的所有 Call 对象

```java
  // org.apache.hadoop.ipc.Server.Connection 
  public class Connection {
      // ........
  }
```

> 部分成员变量

```java
    private SocketChannel channel; // 与客户端连接的 socketchannel 对象
    private ByteBuffer data;       // 实际数据缓冲区
    private ByteBuffer dataLengthBuffer; // 数据长度缓冲区
    private LinkedList<Call> responseQueue; // 此 连接上的所有 Call 对象
    private Socket socket;
    String protocolName;    // 协议名称，即远程调用哪个对象的哪个方法
    // 远程客户端的地址，当 socket 连接断开后，可以通过这些信息进行重连
    private String hostAddress; 
    private int remotePort;
    private InetAddress addr;
```

> 部分成员函数

> Reader.run() --> Listener.doRead() --> conn.readAndProcess() --> conn.processOneRpc(byte[] buf) --> conn.processRpcRequest(RpcRequestHeaderProto, DataInputStream) --> callQueue.put(call)

```java
    // 详情见：org.apache.hadoop.ipc.Client.Connection.sendRpcRequest(Call)
    // 客户端发过来的序列化call之后的内容包括：
    // 0) Length 下面两个部分的总长度
    // 1) RpcRequestHeader
    // 2) RpcRequest      
    // 从 socketchannel 中读取数据
    public int readAndProcess()
        throws WrappedRpcServerException, IOException, InterruptedException {
      while (true) {
        // 1. 读取 Length ，客户端发过来的数据总长度
        int count = -1;
        if (dataLengthBuffer.remaining() > 0) {
          count = channelRead(channel, dataLengthBuffer); 
          // ........
        }
        // 2. 读取客户端发过来的 RpcRequestHeader
        if (!connectionHeaderRead) {
          // .......
          count = channelRead(channel, connectionHeaderBuf);
          // ......
          // header 中的 version 字段
          int version = connectionHeaderBuf.get(0);
          // header 中的 serviceClass 字段
          this.setServiceClass(connectionHeaderBuf.get(1));
          dataLengthBuffer.flip();
          // .........
          continue;
        }
        // 3. 读取客户端发过来的 RpcRequest
        // .........
        count = channelRead(channel, data);
        // 解析数据
        if (data.remaining() == 0) {
          // ........
          processOneRpc(data.array());  // 解析数据
          // ........
        } 
        return count;
      }
    }
    // 初步解析 RPC 请求数据
    private void processOneRpc(byte[] buf)
        throws IOException, WrappedRpcServerException, InterruptedException {
      int callId = -1;
      int retry = RpcConstants.INVALID_RETRY_COUNT;
      try {
        final DataInputStream dis =
            new DataInputStream(new ByteArrayInputStream(buf));
        final RpcRequestHeaderProto header =
            decodeProtobufFromStream(RpcRequestHeaderProto.newBuilder(), dis);
        callId = header.getCallId();
        retry = header.getRetryCount();
        // 进行一些必要检测
        // .......
        // 进行进一步解析
        processRpcRequest(header, dis);
      } catch (WrappedRpcServerException wrse) {
        // ...........
      }
    }
    // 进一步解析 RPC 请求 
    private void processRpcRequest(RpcRequestHeaderProto header,
        DataInputStream dis) throws WrappedRpcServerException,
        InterruptedException {   
      // 从 header中解析得到请求参数 Writable 具体类的 Class 类型
      Class<? extends Writable> rpcRequestClass = 
          getRpcRequestWrapper(header.getRpcKind());
      // .........
      Writable rpcRequest; 
      try { 
        // 反射得到Class的实例
        rpcRequest = ReflectionUtils.newInstance(rpcRequestClass, conf);
        // 为实例赋值
        rpcRequest.readFields(dis);
      } catch (Throwable t) { 
        // .........
      }
      // 将请求数据封装为 Call 对象
      Call call = new Call(header.getCallId(), header.getRetryCount(), rpcRequest, this, ProtoUtil.convert(header.getRpcKind()), header.getClientId().toByteArray());
      // 将 call 添加到 call 队列中， Handler 线程会循环遍历这个队列，处理每一个call
      callQueue.put(call);
      // 增加 RPC 的数量
      incRpcCount();  
    }
```

#### 4.3.2.4 ConnectionManager

> 负责将 channel 封装为 connection 对象，并将 connection对象添加到 connection池中，同时提供定时任务，定时扫描并关闭空闲 connection。

```java
 // org.apache.hadoop.ipc.Server.ConnectionManager
  private class ConnectionManager {
      //........
  }
```

> 部分成员变量

```java
final private Set<Connection> connections; // connection对象集合
```

> 部分成员函数

```java
    // 注册 channel ： 将 channel 封装到 Connection 对象中，并添加到 connection对象集合中
    Connection register(SocketChannel channel) {
      Connection connection = new Connection(channel, Time.now());
      add(connection);
      return connection;
    }
    // 添加 connection 对象到队列中
    private boolean add(Connection connection) {
      boolean added = connections.add(connection);
      if (added) {
        count.getAndIncrement();
      }
      return added;
    }
    // 启动空闲connection扫描线程
    void startIdleScan() {
      scheduleIdleScanTask();
    }
    private void scheduleIdleScanTask() {
      if (!running) {
        return;
      }
      TimerTask idleScanTask = new TimerTask(){
        @Override
        public void run() {
          if (!running) {
            return;
          }
          try {
            closeIdle(false);
          } finally {
            scheduleIdleScanTask();
          }
        }
      };
      // 间隔 idleScanInterval 时间执行一次 idleScanTask 任务
      idleScanTimer.schedule(idleScanTask, idleScanInterval);
    }
    // 关闭空闲 connection 
    synchronized void closeIdle(boolean scanAll) {
      long minLastContact = Time.now() - maxIdleTime;
      int closed = 0;
      for (Connection connection : connections) {
        if (!scanAll && size() < idleScanThreshold) {
          // connection总数量还没达到指定阈值，不需要关闭 connection 
          break;
        }
        // stop if not scanning all and max connections are closed
        if (connection.isIdle() &&
            connection.getLastContact() < minLastContact &&
            close(connection) &&
            !scanAll && (++closed == maxIdleToClose)) {
          break;
        }
      }
    }
```

#### 4.3.2.5 Handler

> 在新的线程中执行实际函数，并获得返回值，然后调用 responder.doRespond(call) 将结果发送到客户端

```java
  // org.apache.hadoop.ipc.Server.Handler
  private class Handler extends Thread {
      // ......
  }
```

> 成员函数分析

```java
    public void run() {
      ByteArrayOutputStream buf = new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
      while (running) {
        try {
          final Call call = callQueue.take(); // 从队列中 pop 出call，此处可能会阻塞
          // ..........
          CurCall.set(call);
          try {
            // 在本地调用 call 对象，并获得返回值
            if (call.connection.user == null) {
              value = call(call.rpcKind, call.connection.protocolName, call.rpcRequest, call.timestamp);
            } else {
              value = call.connection.user.doAs
                (new PrivilegedExceptionAction<Writable>() {
                     @Override
                     public Writable run() throws Exception {
                       return call(call.rpcKind, call.connection.protocolName, call.rpcRequest, call.timestamp);
                     }
                   }
                 );
            }
          } catch (Throwable e) {
            // .........
          }
          CurCall.set(null);
          synchronized (call.connection.responseQueue) {
            // .......
            setupResponse(buf, call, returnStatus, detailedErr, value, errorClass, error);
            // ......
            responder.doRespond(call);
          }
        } catch (Exception e) {
            // .......
        }
      }
    }
```

#### 4.3.2.6 Responder

> 负责在新的线程中将执行完成的 call 对象发送到客户端

> ① Handler 一旦完成一个 call 的调用，则会调用 responder.doRespond(call)， 间接调用 responder.processResponse() 函数，在 processResponse() 函数中，首先会将 call 的返回值写入 channel，如果没有一次性写完，会将此 channel 注册到selector中；

> ② responder 的独立线程中会一直监听 selector 中的就绪时间，不停将 call 写入到对应的就绪channel 里面。

```java
  // org.apache.hadoop.ipc.Server.Responder
    // Sends responses of RPC back to clients.
  private class Responder extends Thread {
    //......
  }
```

> 部分成员变量

```java
    private final Selector writeSelector;   
    private int pending;         // 等待注册的连接数
```

> 部分成员函数

> run() --> doRunLoop() --> doAsyncWrite() -->  processResponse() --> channelWrite()

> Handler.run() --> responder.doRespond(call) --> processResponse() --> channelWrite()

```java
    public void run() {
        // ......
        doRunLoop();
        // .....
    }
    private synchronized void waitPending() throws InterruptedException {
      while (pending > 0) {
        wait();  // 等待
      }
    }
    // 线程循环部分：循环等待 selector 上的读取
    private void doRunLoop() {
      // .........
      while (running) {
        try {
          waitPending();
          // 获得就绪 Channel 对象
          writeSelector.select(PURGE_INTERVAL);
          Iterator<SelectionKey> iter = writeSelector.selectedKeys().iterator();
          while (iter.hasNext()) {
            SelectionKey key = iter.next();
            iter.remove();
            try {
              if (key.isValid() && key.isWritable()) {
                  doAsyncWrite(key); //
              }
            } catch (IOException e) {
                // .........
            }
          }
          // ......
          // 获得就绪 Channel 对象相关的 Call 对象，并从缓存中全部删除
          ArrayList<Call> calls;
          synchronized (writeSelector.keys()) {
            calls = new ArrayList<Call>(writeSelector.keys().size());
            iter = writeSelector.keys().iterator();
            while (iter.hasNext()) {
              SelectionKey key = iter.next();
              Call call = (Call)key.attachment();
              if (call != null && key.channel() == call.connection.channel) { 
                calls.add(call);
              }
            }
          }
          for(Call call : calls) {
            doPurge(call, now);
          }
        } catch (Exception e) {
           // .......
        }
      }
    }
    // 同步块，从 SelectionKey 对象中回去 call 对象，并调用 processResponse() 函数处理这个 call 对象
    private void doAsyncWrite(SelectionKey key) throws IOException {
      Call call = (Call)key.attachment();
      // .......
      synchronized(call.connection.responseQueue) {
        if (processResponse(call.connection.responseQueue, false)) {
          // ......
        }
      }
    }
    // 处理响应：调用 channelWrite() 将 call 对象写入 channel 中，并将处理过的 call 对象从队列中删除
   private boolean processResponse(LinkedList<Call> responseQueue, boolean inHandler) throws IOException {
      boolean error = true;
      boolean done = false;
      int numElements = 0;
      Call call = null;
      try {
        synchronized (responseQueue) {
          // .......
          // pop 出第一个 call 对象
          call = responseQueue.removeFirst();
          // 获得 call 对象对应的 socketchannel 对象
          SocketChannel channel = call.connection.channel;
          // ........
          // 将call的返回值 rpcResponse 写入到 channel 对象
          int numBytes = channelWrite(channel, call.rpcResponse);
          // .......
          if (!call.rpcResponse.hasRemaining()) {
            // 清空 call.rpcResponse
            // .......
          } else {
            // 将不能一次性写入所有的 response，则重新加入到 selector 中
            call.connection.responseQueue.addFirst(call);
            if (inHandler) {
              //......
              incPending();
              try {
                writeSelector.wakeup();
                channel.register(writeSelector, SelectionKey.OP_WRITE, call);
              } 
              // .........
            }
         }
      } finally {
          // ...........
          channel.closeConnection(call.connection);
        }
      }
      return done;
    }
    // 将 call对象 加入到队列中
    void doRespond(Call call) throws IOException {
      synchronized (call.connection.responseQueue) {
        call.connection.responseQueue.addLast(call);
        if (call.connection.responseQueue.size() == 1) {
          processResponse(call.connection.responseQueue, true);
        }
      }
    }
```

#### 4.3.2.7 Server 分析

> 部分成员变量

```java
  private String bindAddress;   
  private int port;              // 当前监听的本地端口 
  private int handlerCount;      // Handler 线程的数量
  private int readThreads;       // Reader 线程的数量
  private int readerPendingConnectionQueue; // 每个 Reader 线程中的 connection 队列长度
  private Class<? extends Writable> rpcRequestClass;   // 反序列化 RPC 请求的 Class 类
  volatile private boolean running = true;  // true while server runs
  private CallQueueManager<Call> callQueue; // 
  // maintains the set of client connections and handles idle timeouts
  private ConnectionManager connectionManager;  // connection 管理类
  private Listener listener = null;         // Listener 对象
  private Responder responder = null;       // Responder 对象
  private Handler[] handlers = null;        // Handler 对象数组
```

> 部分成员函数

> Server.Server() --> new Listener() --> Server.bind()

```java
  // 绑定 ServerSocket 到指定的端口
  public static void bind(ServerSocket socket, InetSocketAddress address, 
      int backlog, Configuration conf, String rangeConf) throws IOException {
    try {
      IntegerRanges range = null;
      if (rangeConf != null) {
        range = conf.getRange(rangeConf, "");
      }
      if (range == null || range.isEmpty() || (address.getPort() != 0)) {
      // 绑定到指定端口
        socket.bind(address, backlog);
      } else {
      // 绑定到多个端口
        for (Integer port : range) {
          if (socket.isBound()) break;
          try {
            InetSocketAddress temp = new InetSocketAddress(address.getAddress(), port);
            socket.bind(temp, backlog);
          } catch(BindException e) {
          }
        }
      }
    } catch (SocketException e) {
    }
  }  
  // 构造函数
  protected Server(String bindAddress, int port, 
      Class<? extends Writable> rpcRequestClass, int handlerCount,
      int numReaders, int queueSizePerHandler, Configuration conf,
      String serverName, SecretManager<? extends TokenIdentifier> secretManager,
      String portRangeConfig) throws IOException { 
    // 进行一些初试赋值（通过传入参数或者 conf）
    // ......
    // 创建 Listener 对象，其中会进行以下操作：
    // 1. 绑定本地端口，Listener()构造函数中会调用 Server对象的 bind() 函数
    // 2. 创建多个 Reader 对象，并启动每个 reader 线程
    // 3. 创建 ServerSocketChannel 和 Selector 对象，并将前者注册到后者
    listener = new Listener();
    // 创建 connection 管理器对象
    connectionManager = new ConnectionManager();
    // 创建 Responder 对象
    responder = new Responder();
    // ........
  }
  // 启动 Server
  public synchronized void start() {
    // 1. 启动 responder 线程
    responder.start();
    // 2. 启动 listener 线程
    listener.start();
    // 3. 创建多个Handler对象，并启动每个Handler对象线程
    handlers = new Handler[handlerCount]; 
    for (int i = 0; i < handlerCount; i++) {
      handlers[i] = new Handler(i);
      handlers[i].start();
    }
  }
  // 将调用结果序列化到 ByteBuffer 中，并赋值到 call 对象中
  private void setupResponse(ByteArrayOutputStream responseBuf,
                             Call call, RpcStatusProto status, RpcErrorCodeProto erCode,
                             Writable rv, String errorClass, String error) throws IOException {
    responseBuf.reset();
    DataOutputStream out = new DataOutputStream(responseBuf); 
    // 构造返回头信息
    RpcResponseHeaderProto.Builder headerBuilder =  
        RpcResponseHeaderProto.newBuilder();
    headerBuilder.setClientId(ByteString.copyFrom(call.clientId));
    headerBuilder.setCallId(call.callId);
    headerBuilder.setRetryCount(call.retryCount);
    headerBuilder.setStatus(status);
    headerBuilder.setServerIpcVersionNum(CURRENT_VERSION);
    if (status == RpcStatusProto.SUCCESS) {
      // 调用成功，获得消息 header
      RpcResponseHeaderProto header = headerBuilder.build();
      final int headerLen = header.getSerializedSize();
      // 数据总长度
      int fullLength  = CodedOutputStream.computeRawVarint32Size(headerLen) +
          headerLen;
      try {
        if (rv instanceof ProtobufRpcEngine.RpcWrapper) {
          ProtobufRpcEngine.RpcWrapper resWrapper = 
              (ProtobufRpcEngine.RpcWrapper) rv;
          fullLength += resWrapper.getLength();
          // 1. 先写入数据总长度
          out.writeInt(fullLength);
          // 2. 写入头信息
          header.writeDelimitedTo(out);
          // 3. 写入返回值数据
          rv.write(out);
        } else { // Have to serialize to buffer to get len
          final DataOutputBuffer buf = new DataOutputBuffer();
          rv.write(buf);
          byte[] data = buf.getData();
          fullLength += buf.getLength();
          out.writeInt(fullLength);
          header.writeDelimitedTo(out);
          out.write(data, 0, buf.getLength());
        }
      } catch (Throwable t) {
        // .....
      }
    } else { // Rpc Failure
      // ......
    }
    // ......
    call.setResponse(ByteBuffer.wrap(responseBuf.toByteArray()));
  }
  // 将buffer的数据写入到channel中
  private int channelWrite(WritableByteChannel channel, 
                           ByteBuffer buffer) throws IOException {
    int count =  (buffer.remaining() <= NIO_BUFFER_LIMIT) ?
                 channel.write(buffer) : channelIO(null, channel, buffer);
    if (count > 0) {
      rpcMetrics.incrSentBytes(count);
    }
    return count;
  }
  // 将channel中的数据读取到buffer中
  private int channelRead(ReadableByteChannel channel, 
                          ByteBuffer buffer) throws IOException {
    int count = (buffer.remaining() <= NIO_BUFFER_LIMIT) ?
                channel.read(buffer) : channelIO(channel, null, buffer);
    if (count > 0) {
      rpcMetrics.incrReceivedBytes(count);
    }
    return count;
  }
```


> ==**总结**==：

- **Server** 对象一旦创建，则会启动如下多个线程：
    - 1个 **Listener** 线程，其中会启动多个 **Reader** 线程
    - 多个 **Handler** 线程
    - 1个 **Responder** 线程
- **Listener** 线程负责通过 ServerSocketChannel 监听来自客户端的 socket 连接请求，并将构建好的 socketchannel 对象封装到 **Connection** 对象中，最终添加到 Reader 对象的 Connection 池中。
- **Reader** 线程负责监听其持有的 Connection 对象池中的每个 socketchannel，一旦通道上有 READ 事件就绪，则读取通道上的数据。
- **Connection** 类封装了 **SocketChannel** ，并提供了实际读取和解析 SocketChannel 中的数据的函数（当 Reader 线程监听到某个 SocketChannel 的READ事件就绪时，会调用 Connection 的相关函数进行具体的数据读取和解析操作）， 最终会将读取的数据封装成 **Call** 对象，添加到 **callQueue** 队列中。
- **Handler** 线程负责轮询 **callQueue** 队列，每次从中取出一个 Call 对象，并完成实际调用，将执行的返回值（Writable对象）序列化之后保存在 Call 对象的 rpcResponse 域中，最后通知 **Responder** 线程，将此 Call 对象写入到对应的 SocketChannel 中。
- **Responder** 线程负责将执行完成的 Call 对象写入到 Call.Connection.SocketChannel 中，从而返回客户端。
- **ConnectionManager** 中维持了一个 Connection 池，会定时扫描并处理闲置 Connection。

---

### 4.3.3. RPC

> 在 Client 和 Server 基础之上，实现了 IPC 。

> 一个简单的 RPC 机制。 一个 protocol 就是一个 Java 接口，接口的所有参数和返回值类型必须是以下几种：基础类型，String类型，Writable 类型，以及这些类型的数组。所有接口中的方法必须 抛出 IOException 异常

```java
public class RPC {
    // ........
}
```

> 部分成员函数

```java
   // 获取客户端代理，实际由 RpcEngine 子类创建客户端代理
   public static <T> ProtocolProxy<T> getProtocolProxy(Class<T> protocol,
                                long clientVersion,
                                InetSocketAddress addr,
                                UserGroupInformation ticket,
                                Configuration conf,
                                SocketFactory factory,
                                int rpcTimeout,
                                RetryPolicy connectionRetryPolicy) throws IOException {
    // ........
    return getProtocolEngine(protocol,conf)
            .getProxy(protocol, clientVersion, addr, ticket, conf, factory, rpcTimeout, connectionRetryPolicy);
  }
  // 关闭客户端代理
  public static void stopProxy(Object proxy) {
    // .......
        InvocationHandler handler = Proxy.getInvocationHandler(proxy);
        if (handler instanceof Closeable) {
          ((Closeable) handler).close();
          return;
        }
    // .........
  }
```

#### 4.3.3.1 Builder

> 构建一个 RPC Server 实例

```java
    // 构建 RPC 的 Server对象，实际由 RpcEngine 子类创建Server对象
    public Server build() throws IOException, HadoopIllegalArgumentException {
      // ..........
      return getProtocolEngine(this.protocol, this.conf).getServer(
          this.protocol, this.instance, this.bindAddress, this.port,
          this.numHandlers, this.numReaders, this.queueSizePerHandler,
          this.verbose, this.conf, this.secretManager, this.portRangeConfig);
    }
```

#### 4.3.3.2 Server

> 主要实现了 call 方法

```java
    public Writable call(RPC.RpcKind rpcKind, String protocol,
        Writable rpcRequest, long receiveTime) throws Exception {
      return getRpcInvoker(rpcKind).call(this, protocol, rpcRequest,
          receiveTime);
    }
```

#### 4.3.3.3 RpcInvoker

```java
// org.apache.hadoop.ipc.WritableRpcEngine
public class WritableRpcEngine implements RpcEngine {
    // ........
}
```

#### 4.3.3.4 WritableRpcEngine

> 辅助 RPC 类完成 RPC 的架构搭建， RPC 类都是通过此对象完成动态代理对象和服务器对象的构建的。

> 部分成员变量

```java
  private static ClientCache CLIENTS=new ClientCache(); // Client 对象缓存
```

> 部分成员函数

```java
  // 获得客户端动态代理对象，实际调用将由 Invoker 对象的 invoke 方法发送服务器端完成执行，并得到结果
  public <T> ProtocolProxy<T> getProxy(Class<T> protocol, long clientVersion,
                         InetSocketAddress addr, UserGroupInformation ticket,
                         Configuration conf, SocketFactory factory,
                         int rpcTimeout, RetryPolicy connectionRetryPolicy)
    throws IOException {    
   // .........
    T proxy = (T) Proxy.newProxyInstance(protocol.getClassLoader(),
        new Class[] { protocol }, new Invoker(protocol, addr, ticket, conf,
            factory, rpcTimeout));
    return new ProtocolProxy<T>(protocol, proxy, true);
  }
  // 获得服务器骨架
  public RPC.Server getServer(Class<?> protocolClass,
                      Object protocolImpl, String bindAddress, int port,
                      int numHandlers, int numReaders, int queueSizePerHandler,
                      boolean verbose, Configuration conf,
                      SecretManager<? extends TokenIdentifier> secretManager,
                      String portRangeConfig) 
    throws IOException {
    return new Server(protocolClass, protocolImpl, conf, bindAddress, port,
        numHandlers, numReaders, queueSizePerHandler, verbose, secretManager,
        portRangeConfig);
  }
```

##### 4.3.3.4.1 Invocation 类

> Invocation 类的对象是可以序列化的，其中封装了调用的相关信息

```java
  // org.apache.hadoop.ipc.WritableRpcEngine.Invocation
  private static class Invocation implements Writable, Configurable {
      // .......
  }
```

> 部分成员变量

```java
    private String methodName;  // 调用的方法名称
    private Class<?>[] parameterClasses; // 调用方法的形式参数
    private Object[] parameters;         // 调用方法的实际参数
```

> 部分成员函数

```java
    public void readFields(DataInput in) throws IOException {
        // ....
    }
    public void write(DataOutput out) throws IOException {
        // .......
    }
```

##### 4.3.3.4.2 Invoker 类

> 实现了 接口 InvocationHandler 和 Closeable， 完成调用转发功能

```java
  private static class Invoker implements RpcInvocationHandler {
    // .......
  }
```

> 部分成员变量

```java
    private Client.ConnectionId remoteId;
    private Client client;
    private boolean isClosed = false;
```

> 部分成员函数

```java
    // 首先将调用参数封装到 Invocation 对象中，然后将调用转发给 client.call() ，由 client 负责将调用信息发送到服务器，并得到执行结果
    public Object invoke(Object proxy, Method method, Object[] args)
      throws Throwable {
      // .....
      ObjectWritable value = (ObjectWritable)
        client.call(RPC.RpcKind.RPC_WRITABLE, new Invocation(method, args), remoteId);
      // ........
      return value.get();
    }
```


##### 4.3.3.4.3 Server 类

> 一个 RPC 的 Server， 实现了抽象类 Server 的所有抽象方法 

```java
  // org.apache.hadoop.ipc.WritableRpcEngine.Server
  public static class Server extends RPC抽象类.Server 的所有抽象方法  {
      // ........
  }
```

###### 4.3.3.4.3.1 WritableRpcInvoker

> 实现了接口 RpcInvoker  的 call 方法， Server 中的 call 方法实际是调用这里实现的 call 方法

```java
// org.apache.hadoop.ipc.WritableRpcEngine.Server.WritableRpcInvoker
    static class WritableRpcInvoker implements RpcInvoker {
        // .....
    }
```

> 部分成员函数

```java
    // 服务器端的 call 调用，实际是此函数完成的
      public Writable call(org.apache.hadoop.ipc.RPC.Server server,
          String protocolName, Writable rpcRequest, long receivedTime)
          throws IOException, RPC.VersionMismatch {
       Invocation call = (Invocation)rpcRequest;
        // ......
       // Invoke the protocol method
       try {
          Method method = 
              protocolImpl.protocolClass.getMethod(call.getMethodName(),
              call.getParameterClasses());
          method.setAccessible(true);
          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);
          Object value = method.invoke(protocolImpl.protocolImpl, call.getParameters());
          // ......
          return new ObjectWritable(method.getReturnType(), value);
        } catch (Throwable e) {
          // ........
        }
      }
```

> **==RPC 总结==**:

- **RPC** 是基于之前的 **Client** 和 **Server**，并结合了 **RpcEngine** 的实现类  (分析的 **WritableRpcEngine** 是其实现类)， 向上层提供 RPC 服务。
- 获取RPC动态代理对象 **Proxy**： 
```
--- proxy = RPC.getProxy(Class<T> protocol, ...)
--> RPC.getProtocolProxy() 
--> WritableRpcEngine.getProxy() 
--> Proxy.newProxyInstance(protocol.getClassLoader(), 
                           new Class[] { protocol }, 
                           new Invoker(protocol, addr, ticket, conf, factory, rpcTimeout))
```
- 通过动态代理对象 **Proxy** 进行远程调用：RPC 客户端的远程调用，是通过 **WritableRpcEngine.Invoker** 完成调用转发的，RPC 构建动态代理时传入的则是此处的 **Invoker** 对象。

```
--- result = proxy.oneMethod(params)
--> WritableRpcEngine.Invoker.invoke()
--> ClientCache.getClient()
--> client.call(RPC.RpcKind.RPC_WRITABLE, new Invocation(method, args), remoteId)
```
- **Invocation** 类是一个可序列化的类，此类的对象会先将远程调用信息进行封装，即为 **rpcRequest** 对象，然后再传给 **client.call()**， 经过序列化之后发送到服务器端；服务器端会反序列化得到此 **Invocation** 的对象，即 **rpcRequest**， 然后在服务器端完成相应的调用，最后将执行结果返回到客户端。

- 服务器端的 **Server** 对象可由 **RPC.Builder** 构造得到，通过这种方法构造得到的 **Server** 对象实际是 **WritableRpcEngine.Server** 的对象：
```
--- server = RPC.Builder.build()
--> WritableRpcEngine.getServer()
--> new WritableRpcEngine.Server()
```
- **Server** 继承关系：**WritableRpcEngine.Server** -->  **RPC.Server** --> **Server**。 抽象类 **Server** 的 **call()**  函数是抽象的，其实现是在 **RPC.Server** 中完成的，实际是间接调用了 **WritableRpcEngine.Server.WritableRpcInvoker** 对象的 **call()** 方法完成的服务器端的调用：
```
--- Server.Handler.run()
--> Server.call()
--> RPC.Server.call()
--> WritableRpcEngine.Server.WritableRpcInvoker.call()
--> Invocation call = (Invocation)rpcRequest
--> Object value = method.invoke()
```

